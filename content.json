{"pages":[],"posts":[{"title":"AJAX异步交互技术之核心对象分析","text":"概述AJAX AJAX为”Asynchronous Javascript And XML”的缩写，即异步的JavaScript和XML。这是一种实现网页异步交互的动态开发技术，即在不重载整个页面的情况下，与服务器交互更新部分网页。这种技术避免了由于频繁的网页请求而造成的多余负载，更提升了用户体验。 概述XMLHttpRequest 关于ajax异步交互技术，其最重要的核心就是XMLHttpRequest对象。XMLHttpRequest对象分属于XML DOM（XML文档对象模型），此对象能够实现网页交互中的：1、在不重新加载页面的情况下更新网页2、在页面已加载后从服务器请求数据3、在页面已加载后从服务器接收数据4、在页面已加载后从服务器接收数据 Ajax是一种异步更新网页的技术，而XMLHttpRequest就提供了浏览器到服务端之间的异步收发控制功能。所以，XMLHttpRequest是Ajax技术及其重要的组成部分。 XMLHttpRequest对象创建 通过一行简单的JS代码，就可以将XMLHttpRequest对象赋值到定义的变量(以下变量名定义为request)，完成创建。 语法：var request=new XMLHttpRequest(); //支持IE7以上及所有现代浏览器 语法：var request=new ActiveXObject(“Microsoft.XMLHTTP”); //老版本IE5和6的兼容写法，看需求选择。 XMLHttpRequest对象发送请求与获取响应 发送请求：1、.open(method,url,async) //建立连接例如：request.open(“get”,”index.php”,true); 与目标服务器建立连接的方法，规定了请求的类型，URL，以及是否是异步处理请求。method:请求类型参数，可选get或post。url:请求的目标URL参数，指目标在服务器上的位置。async:布尔值参数，true(异步)或false(同步),默认为true。 2、.setRequestHeader(header,value) //向请求添加HTTP头例如：request.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded”); header: 规定头的名称value: 规定头的值 3、.send(string) //添加提交内容例如：request.send(“name=王二狗&amp;sex=男”)； 将请求内容发送到服务器的方法，此方法string仅适用于POST类型请求，GET类型默认置空，因为GET请求的内容是附加在URL上的。 获取响应：如需获得来自服务器的响应，需要使用XMLHttpRequest对象的responseText或responseXML 属性。 1、.responseText 获得字符串形式的响应数据。例如：document.getElementById(“myDiv”).innerHTML=request.responseText; 2、.responseXML 获得 XML 形式的响应数据。例如：document.getElementById(“myDiv”).innerHTML=request.responseXML; onreadystatechange 事件获知请求发送状态 当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当准备状态改变时，就会触发 onreadystatechange 事件。事件的readyState 属性存有 XMLHttpRequest 的状态信息。下面是 XMLHttpRequest 对象的三个重要的属性： 1、onreadystatechange //存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 2、readyState //存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 3、status //存有http状态码 200: “OK” 404: 未找到页面 在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。当 readyState 等于 4 且状态为 200 时，表示响应已就绪。例如： 1234567xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; } } 注释：onreadystatechange 事件被触发 5 次（0 - 4），对应着 readyState 的每个变化。 以上就是JavaScript编写AJAX异步交互时常用到的属性、方法，编写完前端的JS代码，配合后端编写的服务端AJAX交互代码，就可以完成网页的异步更新了。 声明：以上内容如有错漏，敬请联系指正，转载请注明出处。","link":"/2019/06/04/AJAX%E5%BC%82%E6%AD%A5%E4%BA%A4%E4%BA%92%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/"},{"title":"git本地项目版本管理及推送至远程仓库","text":"环境 centos 7 本地仓库操作 1、Github上新建一个远程仓库。 2、切换至项目根目录下。 3、创建本地仓库 1$ git init #生成.git目录，授权git本地仓库。 4、添加文件 1$ git add ./* #添加指定文件至暂存区，./*意思是当前目录下所有文件 5、仓库状态查询 1$ git status #工作状态查询命令，执行后提示刚添加的文件已在暂存区中 6、提交文件 1$ git commit -m \"frst commit\" #把暂存区中的文件提交至仓库，引号中为版本描述 7、删除暂存区文件 1$ git reset HEAD xxxx.txt #将已添加至暂存区的文件回滚 8、清理工作区缓存 1$ git checkout -- xxxx.txt #清理刚删除的文件缓存 9、已提交，版本回滚 9.1、查看分支 1$ git log #找到上一个版本commit号 9.2、版本回滚 1$ git reset --hard 9b4d5da3e......... #将暂存区文件和最终文件都回滚到上一次提交 10、清空本地仓库 10.1、清空命令 1$ git rm ./* #将本地仓库中的文件都删除清空 10.2、确认清空 1$ git commit -m \"delete ./*\" #提交确认清空 *、期间可随时用git status查看仓库工作状态 提交至远程仓库 1、添加远程仓库地址 1$ git remote add origin https://xxxxx.git #关联远程仓库，链接在建立的远程仓库获取 2、本地仓库与远程仓库同步 1$ git pull --rebase origin master #获取远程库与本地同步合并，远程仓库不为空时使用 3、提交至远程仓库 1$ git push -u origin master #将本地master分支文件提交至远程仓库 4、工作区中文件被误删，从本地仓库恢复文件 1git checkout xxxxxx *、后续版本迭代，只需将已修改的文件上传提交即可。 声明: 以上内容仅供参考，转载请注明出处。","link":"/2019/04/26/Git%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%8F%8A%E6%8E%A8%E9%80%81%E8%87%B3%E8%BF%9C%E7%A8%8B/"},{"title":"JavaScript-BOM对象之location","text":"Location对象方法 简介：Location是一个URL操作方法，这对象中包含了有关当前URL的信息。Location对象是Window对象的一部分，可以通过window.location属性来访问。 1、assign()方法，用于加载一个指定URL的新文档 语法：location.assign(URL) 实例： 12345678910111213141516&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;function newDoc() &lt;!-- 定义一个点击事件函数 --&gt; { window.location.assign(\"http://www.w3school.com.cn\") } &lt;!-- assign()引用自window对象，所以'window.'加不加均可 --&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" value=\"Load new document\" onclick=\"newDoc()\" /&gt; &lt;!-- 定义button按钮，引用定义的函数 --&gt;&lt;/body&gt;&lt;/html&gt; 2、reload()方法，用于重载当前文档。 语法：location.reload(force) 说明：如果该方法不设参数或参数为false，会检测目标文件是否有修改而选择是否重新下载刷新，是则重新下载文档刷新，否则基于缓存刷新。如果该方法参数设为true,则无论目标文件是否有过修改，都会绕过缓存，从目标服务器重新下载文档来刷新。 实例： 12345678910111213141516&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;function reloadPage() &lt;!-- 定义重载函数 --&gt; { window.location.reload() }&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" value=\"Reload page\" onclick=\"reloadPage()\" /&gt; &lt;!-- 定义按钮引用函数 --&gt;&lt;/body&gt;&lt;/html&gt; 3、replace()方法，可用一个新的文档取代当前文档 语法：location.replace(newURL) 说明：replace与assign()方法类似，不同之处在于assign()跳转为新页面时，可以点击后退返回上一个页面。而replace()是用一个新的页面来代替原页面，是无法返回原页面的。w3school中说明为：replace() 方法不会在 History 对象中生成一个新的记录。当使用该方法时，新的 URL 将覆盖 History 对象中的当前记录。 实例： 123456789101112131415&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;function replaceDoc() &lt;!-- 定义替代函数 --&gt; { window.location.replace(\"http://www.w3school.com.cn\") }&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" value=\"Replace document\" onclick=\"replaceDoc()\" /&gt; &lt;!-- 定义按钮引用函数 --&gt;&lt;/body&gt;&lt;/html&gt; Location对象属性hash 设置或返回从井号 (#) 开始的 URL（锚）。host 设置或返回主机名和当前 URL 的端口号。hostname 设置或返回当前 URL 的主机名。href 设置或返回完整的 URL。pathname 设置或返回当前 URL 的路径部分。port 设置或返回当前 URL 的端口号。protocol 设置或返回当前 URL 的协议。search 设置或返回从问号 (?) 开始的 URL（查询部分）。 语法：location.属性名 三、Location对象描述Location 对象存储在 Window 对象的 Location 属性中，表示那个窗口中当前显示的文档的 Web 地址。它的 href 属性存放的是文档的完整 URL，其他属性则分别描述了 URL 的各个部分。这些属性与 Anchor 对象（或 Area 对象）的 URL 属性非常相似。当一个 Location 对象被转换成字符串，href 属性的值被返回。这意味着你可以使用表达式 location 来替代 location.href。 不过 Anchor 对象表示的是文档中的超链接，Location 对象表示的却是浏览器当前显示的文档的 URL（或位置）。但是 Location 对象所能做的远远不止这些，它还能控制浏览器显示的文档的位置。如果把一个含有 URL 的字符串赋予 Location 对象或它的 href 属性，浏览器就会把新的 URL 所指的文档装载进来，并显示出来。 除了设置 location 或 location.href 用完整的 URL 替换当前的 URL 之外，还可以修改部分 URL，只需要给 Location 对象的其他属性赋值即可。这样做就会创建新的 URL，其中的一部分与原来的 URL 不同，浏览器会将它装载并显示出来。例如，假设设置了Location对象的 hash 属性，那么浏览器就会转移到当前文档中的一个指定的位置。同样，如果设置了 search 属性，那么浏览器就会重新装载附加了新的查询字符串的 URL。 除了 URL 属性外，Location 对象的 reload() 方法可以重新装载当前文档，replace() 可以装载一个新文档而无须为它创建一个新的历史记录，也就是说，在浏览器的历史列表中，新文档将替换当前文档。 声明：以上内容如有错漏，敬请联系指正，转载请注明出处。","link":"/2019/05/20/JavaScript-BOM%E5%AF%B9%E8%B1%A1%E4%B9%8Blocation/"},{"title":"JavaScript-BOM窗口对象三板斧","text":"概述 Window对象表示浏览器中打开的窗口。 如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。 浏览器实现的前进后退功能、打开关闭新标签功能，均是在window对象的基础上实现的，而在前端开发中还是利用window对象开发各式各样的验证提示对话框。 Window对象三方法实现不同功能的窗口交互 1、alert(message)这是一个经常用到一个弹窗方法，引用方法并传入需要输出的字符，变量，就会以 字符型消息窗口 的形式输出传入内容。 message 表示要在window上弹出的对话框中显示的纯文本（而非HTML文本） 实例 12345678910111213&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt; alert(\"我是一个可爱的小弹窗\"); &lt;!-- alert()弹出一段文字 --&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 2、confirm(message)相比单纯alert()弹窗，confirm()提供了带布尔值的 确认(true)or取消(false) 按钮。 实例 12345678910111213141516171819&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;var r=confirm(\"请按下按钮\");if (r==true) &lt;!-- 确定true --&gt; { alert(\"你按下了-&gt;确定\"); }else &lt;!-- 取消false --&gt; { alert(\"你按下了-&gt;取消\"); }&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 3、prompt(text,defaultText)上面两种弹窗方法都没有提供输入功能，只是单纯的弹出消息。而这个 prompt() 方法便提供了可供用户输入的对话框。按确定，就会提交用户当前输入的内容，按取消，则返回null。 text 可选，这个参数可以定义对话框的纯文本提示内容defaultText 可选，这个参数可以定义对话框中输入框的默认值。 实例 123456789101112131415&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt; var name=prompt(\"请输入你的名字\",\"小明啊\") if (name!=null &amp;&amp; name!=\"\") { document.write(\"Hello \" + name + \"!\") } &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 以上三种常用对话框方法，在真正的生产环境中，可以使用代码调节实现更多应用，使窗口更加美观。 声明：以上内容如有错漏，敬请联系指正，转载请注明出处。","link":"/2019/05/28/JavaScript-BOM%E7%AA%97%E5%8F%A3%E5%AF%B9%E8%B1%A1%E4%B8%89%E6%9D%BF%E6%96%A7/"},{"title":"PHP中的变量与函数特性","text":"PHP中的两种变量定义方法 定义一个变量有两种方法：$这个符号在定义初始化，或者使用的时候都是必须要有的。 示例： 12345678910$name = \"php\"; //一般变量的定义class Phpgood{var $talk = \"真好\"; //只能在类里用}$phpgood = new Phpgood();echo $name;echo $phpgood-&gt;talk; 第一种方法，可以定义一般变量和类的属性变量，在类里定义属性变量时，需加访问控制关键字，不携带默认访问权限。 第二种方法，只能定义类的属性变量，用var定义，在类里定义属性变量的时，可以不加访问控制关键字，默认携带”公有”访问权限，不常用的写法。 PHP中的函数 PHP中的函数就是用于完成某些功能的代码段，分为系统函数和自定义函数。 系统函数是指PHP中原生内置的函数，无需开发者封装，使用函数名调用即可。例如：echo、var_dump。示例： 123echo \"你好\"; //echo加不加括号都可以。var_dump(\"PHP\"); 自定义函数是指按照具体需求，由开发者封装的函数。示例： 12345function outPut(){ var_dump(\"我是函数输出的内容\");}outPut(); 函数的传值与传引用 传值:默认情况下，函数参数通过值传递，所以即使在函数内部改变参数的值也不会改变函数外部的值。 12345678function test($i){ $i+=10; var_dump($i);}$i=2;test($i); //传值进去，输出12var_dump($i); //输出2 传引用：可以通过在参数前添加取地址符&amp;，代表通过引用传递参数，在函数内部对其所做操作影响其本身。 12345678function test(&amp;$i){ $i+=10; var_dump($i);}$m=2;test($m); //传变量地址进去，输出12var_dump($m); //输出12 自定义函数的包含 对于想在多处使用已封装好的自定义函数，可以使用包含函数文件的方式，可以避免多处重写相同函数。 两种包含方式：require/require_once 123require 'xxxx.php'; //同文件多次包含，多次生效require_once 'xxxx.php'; //同文件多次包含，只生效一次 通过require/require_once包含的文件不存在时，会产生一个致命错误和一个警告，程序终止执行。 include/include_once 123include 'xxxx.php';include_once 'xxxx.php'; 通过include/include_once包含的文件不存在时，会产生两个警告，程序继续执行。 require是一个预置行为，无条件的包含。这个函式通常放在PHP程式的最前面，PHP程式在执行前，就会先包含require所指定文件，即使可能不执行。 include是一个过程行为，有条件的包含。这个函式通常放在流程控制的处理区段中，PHP程式网页在读到include的档案时，才将它读进来，引入是有条件的，发生在程序执行时，只有条件成立时才导入，可简化编译生成的代码。 PHP中echo与var_dump函数的区别 echo与var_dump的核心功能同样是没有区别的，皆为“输出变量的值”，echo只能输出变量的值，var_dump能将变量的值与类型同时输出。 var_dump对于变量、数组、类的输出，有着很好的表现，通过var_dump能够轻易地观察出变量、数组、类此时的值为多少。而echo则报错成狗，当然，在普通网页的输出，我们也不希望软件产品客户看到var_dump输出的信息，所以echo还是最基础的东西。 echo偏向于产品，给客户看的，调试人员、编程人员更适合使用var_dump来输出变量， 函数or方法有什么区别 function函数：函数，是一个面向过程的算法的实现，是独立存在的，也就是指全局作用域里的函数，可以在任何地方调用。 function方法：方法，是一个面向对象的业务逻辑的实现，对象里依赖于类存在的，即类的方法。 源自：本篇文章为慕课网PHP入门教程的知识总结声明：以上内容如有不足之处，欢迎联系指正，转载请注明出处！","link":"/2019/08/17/PHP%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7/"},{"title":"PHP中的字符串处理","text":"字符串简介 字符串是PHP中重要的数据类型之一，属于标准变量类型。一个字符串(string)就是由一些列字符组成，每个字符等同于一个字节，字符串需要书写到定界符中。 定界符的使用 常用定界符： 单引号 双引号 heredoc结构 nowdoc结构 单引号和双引号 单引号不解析变量和特殊符号，定界符中的字符会以纯字符输出。 双引号会解析变量和特殊符号，定界符中的字符会先解析再输出。12echo 'string\\n'; //输出string\\necho \"string\\n\"; //输出sting后换行 heredoc结构和nowdoc结构 heredoc结构：通过heredoc结构定界符来写字符串，相当于双引号的作用。与直接用双引号不同的是，在heredoc结构中包含有双引号时，不需要使用转义符转义。 12345//开始标记名后不能出现空格或多余的字符。&lt;&lt;&lt;标识名 内容……标识名;//结束标记名前不能有任何内容，像制表符和空格都不可以 示例： 1234567$str=&lt;&lt;&lt;EOH&lt;h1 style=\"color:blue\"&gt; \"php\",贼厉害。&lt;/h1&gt;EOH;echo $str; //输出蓝色字体，h1格式的：\"php\",贼厉害。 nowdoc结构：通过nowdoc结构定界符来写，相当于单引号的作用。但不同的是单引号无需转义，省去了多次转义单引号的工作量。 12345//开始标记名后不能出现空格或多余的字符,标识名需要用单引号扩起来&lt;&lt;&lt;'标识名' 内容……标识名;//结束标记名前不能有任何内容，像制表符和空格都不可以 123456$str=&lt;&lt;&lt;'EON'hello nowdoc结构&lt;br/&gt;{$user}EON;echo $str; //输出：hello nowdoc结构 {$user} heredoc结构和nowdoc结构，作用类似于双/单引号，但当内容中出现多处引号时，无需像直接用引号定界符一样，每个引号前都加转义符，提高了工作效率。 特殊字符的转义 在定界符中的字符串内容如果包含引号，与定界符冲突需要使用\\转义，才不会被错误解析。 1echo 'this is \\'string\\''; 常用转义符： \\n 换行 \\r 回车 \\t 水平制表符(Tab) $ 美元标记 ' 单引号 &quot; 双引号 将字符串中的变量扩成一个整体 在输出一个包含变量的字符串，变量后面如果还有字母等字符串，就会影响到变量的解析，这时，我们就需要用{}在字符串中将变量名单独扩起来。 12$str='Sinan';echo \"MyNameIs{$str}Y\"; //输出MyNameIsSinanY 通过{}可以对字符串中的字符做增删改查操作，通过字符数组的形式，字符串下标从0开始。 123456789101112131415$str='abcfef';echo $str; //输出未修改之前的字符串：abcfefecho '&lt;br&gt;';echo $str{3}; //输出下标为3的字符：fecho '&lt;br&gt;';$str{3}='d'; //修改下标为3的字符为：decho $str; //输出修改后的字符串：abcdef//删除：将需要删除的字符下标赋值null或者空即表示删除。$str{5}=null; //或者$str{5}=''，删除下标为5的字符f//增加：给指定下标赋值即可$str{6}='g'; //在下标为5的位置，增加一个g 输出字符串中的一个中文：如果使用utf-8编码，1个文字占用3位下标，所以想用下标的形式输出1个文字，需要输出3位下标。 123456$str='你好';//依次输出下标0~2，成功输出一个中文字符：你echo $str{0};echo $str{1};echo $str{2}; 源自：本篇文章为慕课网PHP入门教程的知识总结声明：以上内容如有不足之处，欢迎联系指正，转载请注明出处！","link":"/2019/08/27/PHP%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"},{"title":"PHP中的异常处理机制","text":"PHP异常处理之异常处理 PHP具有很多异常处理类，其中Exception是所有异常处理的基类。 Exception具有几个基本属性与方法，其中包括了： message 异常消息内容 code 异常代码 file 抛出异常的文件名 line 抛出异常在该文件的行数 其中常用的方法有： getTrace 获取异常追踪信息 getTraceAsString 获取异常追踪信息的字符串 getMessage 获取出错信息 如果必要的话，可以通过继承Exception类来建立自定义的异常处理类。 123456789101112131415161718192021//自定义的异常类，继承了PHP的异常基类Exceptionclass MyException extends Exception { function getInfo() { return '请输入小于或等于1的数&lt;br&gt;'; }}function checkNum($number){ if($number&gt;1){ throw new MyException('异常提示-数字必须小于等于1'); } return true;}try { checkNum(2); echo \"无错误\";} catch(Exception $e) {//\"catch\" 代码块会捕获异常，并创建一个包含异常信息的对象 echo $e-&gt;getInfo();//输出自定义的异常信息：\"请输入小于或等于1的数\" echo $e-&gt;getMessage();//输出继承自基类的getMessage信息：\"异常提示-数字必须小于等于1\"} PHP异常处理之获取错误发生的所在行 为了获取到足够多的异常信息，我们需要将报错的文件名、行号、错误信息、异常追踪信息等记录到日志中，以便调试与修复问题。 示例： 1234567891011121314151617181920function checkNum($number){ if($number&gt;1){ throw new Exception(\"异常提示-数字必须小于等于1\"); } return true;}//在 \"try\" 代码块中触发异常try{ checkNum(2);} catch(Exception $ex) { $msg = 'Error:'.$ex-&gt;getMessage().\"\\n\"; $msg.= $ex-&gt;getTraceAsString().\"\\n\"; $msg.= '异常行号：'.$ex-&gt;getLine().\"\\n\"; $msg.= '所在文件：'.$ex-&gt;getFile().\"\\n\"; //将异常信息记录到日志中 file_put_contents('error.log', $msg); echo $msg;} 源自：本篇文章为慕课网PHP入门教程的知识总结声明：以上内容如有不足之处，欢迎联系指正，转载请注明出处！","link":"/2019/08/17/PHP%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"},{"title":"PHP中的数据库操作扩展","text":"PHP数据库扩展 PHP通过安装相应的扩展来实现数据库操作，PHP中一个数据库可能有一个或者多个扩展，其中既有官方的，也有第三方提供的。像Mysql常用的扩展有原生的mysql库，也可以使用增强版的mysqli扩展，还可以使用PDO进行连接与操作。 不同的扩展提供基本相近的操作方法，不同的是可能具备一些新特性，以及操作性能可能会有所不同。 mysql扩展进行数据库连接的方法： 1$link = mysql_connect('mysql_host', 'mysql_user', 'mysql_password'); mysqli扩展： 1$link = mysqli_connect('mysql_host', 'mysql_user', 'mysql_password'); PDO扩展： 1234$dsn = 'mysql:dbname=testdb;host=127.0.0.1';$user = 'dbuser';$password = 'dbpass';$dbh = new PDO($dsn, $user, $password); PHP数据库操作之连接MySQL数据库 PHP要对数据库进行操作，首先要做的是与数据库建立连接，通常我们使用mysql_connect函数进行数据库连接，该函数需要指定数据库的地址，用户名及密码。 示例： 1234567$host = '127.0.0.1';$user = 'code1';$pass = '';$link = mysql_connect($host,$user,$pass); //在这里编写数据库连接代码mysql_select_db('code1'); //选择需要操作的数据库mysql_query(\"set names 'utf8'\"); //设置当前连接使用的字符编码 PHP数据库操作之执行MySQL查询 在数据库建立连接以后就可以进行查询，采用mysql_query加sql语句的形式向数据库发送查询指令。 1$res = mysql_query('select * from user'); 对于查询类的语句会返回一个资源句柄（resource），可以通过该资源获取查询结果集中的数据。 1$row = mysql_fetch_array($res); 默认的，PHP使用最近的数据库连接执行查询，但如果存在多个连接的情况，则可以通过参数指令从那个连接中进行查询。 123$link1 = mysql_connect('127.0.0.1', 'code1', '');$link2 = mysql_connect('127.0.0.1', 'code1', '', true); //开启一个新的连接$res = mysql_query('select * from user limit 1', $link1); //从第一个连接中查询数据 PHP数据库操作之插入新数据到MySQL中 和数据查询一样，插入数据其实也是通过执行一个sql语句来实现。 12345$name = '李四';$age = 18;$class = '高三一班';$sql = \"insert into user(name, age, class) values('$name', '$age', '$class')\";mysql_query($sql); //执行插入语句 在mysql中，执行插入语句以后，可以得到自增的主键id,通过PHP的mysql_insert_id函数可以获取该id。这个id的作用非常大，通常可以用来判断是否插入成功，或者作为关联ID进行其他的数据操作。 1$uid = mysql_insert_id(); PHP数据库操作之查询分页数据 通过循环可以获取一个查询的所有数据，在实际应用中，我们并不希望一次性获取数据表中的所有数据，那样性能会非常的低，因此会使用翻页功能，每页仅显示10条或者20条数据。 通过mysql的limit可以很容易的实现分页，limit m,n表示从m行后取n行数据，在PHP中我们需要构造m与n来实现获取某一页的所有数据。 假定当前页为$page，每页显示$n条数据，那么m为当前页前面所有的数据，既$m = ($page-1) * $n，在知道了翻页原理以后，那么我们很容易通过构造SQL语句在PHP中实现数据翻页。 12345678910111213141516171819//连接数据库mysql_connect('127.0.0.1', 'code1', '');mysql_select_db('code1');mysql_query(\"set names 'utf8'\");//预设翻页参数$page = 2;$pagesize = 2;//在这里构建分页查询$m = ($page -1)*$pagesize;//获取翻页数据$result = mysql_query($sql);$data = array();while ($row = mysql_fetch_array($result, MYSQL_ASSOC)) { $data[] = $row;}echo '&lt;pre&gt;';print_r($data);echo '&lt;/pre&gt;'; 在上面的例子中，我们使用了$m与$n变量来表示偏移量与每页数据条数，但我们推荐使用更有意义的变量名来表示，比如$pagesize, $start, $offset等，这样更容易理解，有助于团队协作开发。 PHP数据库操作之更新与删除数据 数据的更新与删除相对比较简单，只需要构建好相应的sql语句，然后调用mysql_query执行就能完成相应的更新与删除操作。 更新： 1234$sql = \"update user set name = '曹操' where id=2 limit 1\";if (mysql_query($sql)) { echo '更新成功';} 删除： 1234$sql = \"delete from user where id=2 limit 1\";if (mysql_query($sql)) { echo '删除成功';} 对于删除与更新操作，可以通过mysql_affected_rows函数来获取更新过的数据行数，如果数据没有变化，则结果为0。 1234$sql = \"update user set name = '曹操' where id=2 limit 1\";if (mysql_query($sql)) { echo mysql_affected_rows();} PHP数据库操作之关闭MySQL连接 当数据库操作完成以后，可以使用mysql_close关闭数据库连接，默认的，当PHP执行完毕以后，会自动的关闭数据库连接。 自动关闭数据库连接： 1mysql_closer(); 在存在多个数据库连接，对性能要求比较高的情况下，可以设定连接资源参数来关闭指定的数据库连接，有利于在进行完数据库操作之后尽快关闭数据库连接，以节省资源，提高性能。 关闭指定数据库连接： 12$link = mysql_connect($host, $user, $pass);mysql_close($link); 源自：本篇文章为慕课网PHP入门教程的知识总结声明：以上内容如有不足之处，欢迎联系指正，转载请注明出处！","link":"/2019/08/17/PHP%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E6%89%A9%E5%B1%95/"},{"title":"PHP中的文件处理函数","text":"PHP文件系统之读取文件内容 PHP具有丰富的文件操作函数，最简单的读取文件的函数为file_get_contents，可以将整个文件全部读取到一个字符串中,也可以通过参数控制读取内容的开始点以及长度。 1$content = file_get_contents('./test.txt', null, null, 100, 500); PHP也提供类似于C语言操作文件的方法，使用fopen，fgets，fread等方法，fgets可以从文件指针中读取一行，freads可以读取指定长度的字符串。使用fopen打开的文件，最好使用fclose关闭文件指针，以避免文件句柄被占用。 1234567$fp = fopen('./text.txt', 'rb');$contents = '';while(!feof($fp)) { $content01 .= fgets($fp); //读取一行 $content02 .= fread($fp, 4096); //一次读取4096个字符}fclose($fp); PHP文件系统之判断文件是否存在 一般情况下在对文件进行操作的时候需要先判断文件是否存在，PHP中常用来判断文件存在的函数有两个is_file与file_exists。file_exists不仅可以判断文件是否存在，同时也可以判断目录是否存在，从函数名可以看出，is_file是确切的判断给定的路径是否是一个文件。更加精确的可以使用is_readable与is_writeable在文件是否存在的基础上，判断文件是否可读与可写。 示例： 1234567$filename = '/date/test.txt';//判断如果$filename文件存在的话 就输出文件内容if (file_exists($filename)) { echo '文件存在';}else{ echo '文件不存在';} PHP文件系统之取得文件的修改时间 文件有很多元属性，包括：文件的所有者、创建时间、修改时间、最后的访问时间等。 fileowner：获得文件的所有者 filectime：获取文件的创建时间 filemtime：获取文件的修改时间 fileatime：获取文件的访问时间 示例： 12$mtime = filemtime($filename);echo '修改时间：'.date('Y-m-d H:i:s', filemtime($filename)); PHP文件系统之取得文件的大小 通过filesize函数可以取得文件的大小，文件大小是以字节数表示的。 示例： 123$filename = '/date/test.txt';$size = filesize($filename); PHP文件系统之写入内容到文件 与读取文件对应，PHP写文件也具有两种方式，最简单的方式是采用file_put_contents。 示例： 123$filename = './test.txt';$data = 'test';file_put_contents($filename, $data); 同样的，PHP也支持类似C语言风格的操作方式，采用fwrite进行文件写入。 示例： 1234$fp = fopen('./test.txt', 'w');fwrite($fp, 'hello');fwrite($fp, 'world');fclose($fp); PHP文件系统之删除文件 跟Unix系统命令类似，PHP使用unlink函数进行文件删除。 123$filename = './test.txt';unlink($filename); 删除文件夹使用rmdir函数，文件夹必须为空，如果不为空或者没有权限则会提示失败。 123$filename = './test.txt';rmdir($dir); 如果文件夹中存在文件，可以先循环删除目录中的所有文件，然后再删除该目录，循环删除可以使用glob函数遍历所有文件。 12345$filename = './test.txt';foreach (glob(\"*\") as $filename) { unlink($filename);} PHP异常处理之抛出一个异常 从PHP5开始，PHP支持异常处理，异常处理是面向对象一个重要特性，PHP代码中的异常通过throw抛出，异常抛出之后，后面的代码将不会再被执行。 既然抛出异常会中断程序执行，那么为什么还需要使用异常处理？ 异常抛出被用于在遇到未知错误，或者不符合预先设定的条件时，通知客户程序，以便进行其他相关处理，不至于使程序直接报错中断。 当代码中使用了try catch的时候，抛出的异常会在catch中捕获，否则会直接中断。 1、基本语法 try{ //可能出现错误或异常的代码 //catch表示捕获，Exception是php已定义好的异常类 } catch(Exception $e){ //对异常处理，方法： //1、自己处理 //2、不处理，将其再次抛出 } 2、处理处理程序应当包括：Try - 使用异常的函数应该位于 “try” 代码块内。如果没有触发异常，则代码将照常继续执行。但是如果异常被触发，会抛出一个异常。Throw - 这里规定如何触发异常。注意：每一个 “throw” 必须对应至少一个 “catch”，当然可以对应多个”catch”Catch - “catch” 代码块会捕获异常，并创建一个包含异常信息的对象。 示例： 1234567891011121314151617//创建可抛出一个异常的函数function checkNum($number){ if($number&gt;1){ throw new Exception(\"异常提示-数字必须小于等于1\"); } return true; } //在 \"try\" 代码块中触发异常 try{ checkNum(2); //如果异常被抛出，那么下面一行代码将不会被输出 echo '如果能看到这个提示，说明你的数字小于等于1'; }catch(Exception $e){ //捕获异常 echo '捕获异常: ' .$e-&gt;getMessage(); } 源自：本篇文章为慕课网PHP入门教程的知识总结声明：以上内容如有不足之处，欢迎联系指正，转载请注明出处！","link":"/2019/08/17/PHP%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"},{"title":"PHP中的特殊函数形式","text":"可变函数的使用 在PHP中如果将”函数名称”赋予字符串类型的变量，但是在使用该变量时，如果带有小括号，那么PHP引擎将解析为函数，可变函数需要自己封装之后实现。 12345678//封装一个函数function test($s){ var_dump($s);}$funcName='test'; //将函数名赋给变量//函数名=&gt;变量名，以变量名调用$funcName('吃饭了'); //输出吃饭了 回调函数的使用 回调函数就是调用函数的时候将另一个函数的名称当作参数传递进去(可变函数)，并且在函数体中进行调用。 1234567891011function study(){ echo '学习中';}function doWhat($state){ echo '你正在'; //通过可变函数的形式进行调用 $state();}//将study函数传递进去doWhat('study'); //输出\"你正在学习中\" 匿名函数的使用 匿名函数，也叫闭包函数，指临时创建一个没有指定名称的函数，最经常用作回调函数参数的值，也可以作为变量的值来使用。 12345$func=function(){ //无函数名 return \"匿名函数的输出……\";}; //因为赋给了变量，所以要加;echo $func(); //输出\"匿名函数的输出……\" 递归函数的使用 如果函数A需要调用函数B，而发现函数B的代码实现与函数A完全相同，依次类推，此时就需要封装为递归函数。通俗的讲，就是自己调用自己的函数，通过特定条件结束执行。 12345678910function text($i){ echo $i; --$i; if($i&gt;=0){ //结束执行条件 echo \"-&gt;\"; text($i); //不满足结束条件再次调用——递归 }}text(20); //逆序输出20至0 源自：本篇文章为慕课网PHP入门教程的知识总结声明：以上内容如有不足之处，欢迎联系指正，转载请注明出处！","link":"/2019/08/24/PHP%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0%E5%BD%A2%E5%BC%8F/"},{"title":"PHP中的类与对象特性","text":"PHP类和对象 类是一类东西的结构描述，而对象则是一类东西的一个具体实例。创建一个对象，通常需要写一个类，再将类通过new关键字进行实例化。 示例： 12345678910//定义类class Car { $name = '汽车'; function getName() { return $this-&gt;name; }}$car = new Car(); //实例化类为对象echo $car-&gt;getName(); 类与对象看起来比较相似，但实际上有本质的区别，类是抽象的概念，对象是具体的实例。类可以使程序具有可重用性。 PHP类和对象的访问控制 什么是类和对象的访问控制？顾名思义，就是指类或对象来自外部访问的权限控制。 类或对象的访问控制关键字有： public：公有的 protected：受保护的 private：私有的 PHP语法规定，类属性必须定义为公有、受保护、私有之一，若是类的属性不加上访问控制的前缀将会报错。为兼容PHP5以前的版本，如果采用 var 定义，则被视为公有。 类的方法也可以定义访问权限，默认为公有。 示例： 12345678910//定义一个方法class Room{ $name01 = \"卧室、\"; //属性未定义访问控制，会调用失败并报错 public $name02 = \"客房\"; //定义访问控制为公有，调用成功}$room = new Room(); //实例化方法为对象echo $room-&gt;name01; //输入对象的name01,因未定义访问控制，无法输出。echo $room-&gt;name02; //输出对象的name02，成功输出“客房” PHP中Static静态关键字的作用 静态属性与方法可以在不实例化类的情况下调用，直接使用类名::方法名的方式进行调用。静态属性不允许对象使用-&gt;操作符调用。 静态方法中，$this伪变量不允许使用。可以使用self，static，parent在内部调用静态方法与属性。self和static都是调用变量用的，parent用于调用方法。 示例： 123456789101112131415161718192021222324class Car { private static $speed = 10; public static $setout = \" 时速，出发！\"; public static function getSpeed() { return self::$speed; } public static function speedUp() { return self::$speed+=10; }}class BigCar extends Car { //BigCar继承Car public static function start() { parent::speedUp(); } public static function setout(){ return static::$setout; }}BigCar::start(); //调用静态方法加10echo Car::getSpeed(); //输出静态方法里的值echo BigCar::setout(); PHP类和对象之对象继承 继承是面对对象程序设计中常用的一个特性，同一父类的子类具有很多相同的属性和方法，可以采用继承的特性，来让子类来共享父类的属性和方法，实现代码的复用。 例如汽车就是一个比较大的类，我们也可以称之为基类或父类。汽车这个大类中还分为轿车、货车、越野车等，他们都有一些相同的特性。例如：同样都有轮子、方向盘、刹车、离合。这些相同的特性我们就可以写一个父类，让不同的子类来继承，从而提高代码的复用率。 示例：上面”Static静态关键字的作用”示例中已经有对象继承的内容，下面重点提一下语法。 1234567class Car{ //定义一个类Car}class BigCar extends Car{ //新类BigCar继承类Car的属性方法。} PHP类和对象之重载 PHP中的重载指的是动态的创建属性与方法，是通过魔术方法来实现的。属性的重载通过_set，__get，__isset，__unset来分别实现对不存在属性的赋值、读取、判断属性是否设置、销毁属性。 示例： 12345678910111213141516171819202122232425262728class Car { private $ary = array(); public function __set($key, $val) { $this-&gt;ary[$key] = $val; } public function __get($key) { if (isset($this-&gt;ary[$key])) { return $this-&gt;ary[$key]; } return null; } public function __isset($key) { if (isset($this-&gt;ary[$key])) { return true; } return false; } public function __unset($key) { unset($this-&gt;ary[$key]); }}$car = new Car();$car-&gt;name = '汽车'; //name属性动态创建并赋值echo $car-&gt;name; 方法的重载通过__call来实现，当调用不存在的方法的时候，将会转为参数调用__call方法，当调用不存在的静态方法时会使用__callStatic重载。 123456789101112class Car { public $speed = 0; public function __call($name, $args) { if ($name == 'speedUp') { $this-&gt;speed += 10; } }}$car = new Car();$car-&gt;speedUp(); //调用不存在的方法会使用重载echo $car-&gt;speed; 当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。 源自：本篇文章为慕课网PHP入门教程的知识总结声明：以上内容如有不足之处，欢迎联系指正，转载请注明出处！","link":"/2019/08/17/PHP%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/"},{"title":"PHP之正则表达式简介与会话控制","text":"什么叫正则表达式 正则表达式是对字符串进行操作的一种逻辑公式，就是用一些特定的字符组合成一个规则字符串，称之为正则匹配模式。定义一个正则表达式，它用来匹配源字符串中是否存在是否与该正则表达式对应的字符串。 12345$p = '/苹果/';$str = \"苹果 香蕉\";if (preg_match($p, $str)) { echo '匹配成功';} 存储在客户端的Cookie cookie常用于识别用户。cookie是服务器留在用户计算机中的小文件。每当相同的计算机通过浏览器请求页面时，它同时会发送cookie。通过PHP，能够创建并取回cookie的值。任何从浏览器发回的Cookie，PHP都会自动的将他存储在$_COOKIE的全局变量之中，因此我们可以通过$_COOKIE[‘key’]的形式来读取某个Cookie值。 PHP中的三种cookie设置方法 PHP设置Cookie最常用的方法就是使用setcookie函数，setcookie具有7个可选参数，我们常用到的为前5个： name（ Cookie名）可以通过$_COOKIE[‘name’] 进行访问 value（Cookie的值） expire（过期时间）Unix时间戳格式，默认为0，表示浏览器关闭即失效 path（有效路径）如果路径设置为’/‘，则整个网站都有效 domain（有效域）默认整个域名都有效，如果设置了&lt;www.imooc.com&gt;,则只在www子域中有效 示例： 123456//语法：setcookie(name, value, expire, path, domain);$value = 'test';setcookie(\"TestCookie\", $value);//设置cookie的名，传入的值setcookie(\"TestCookie\", $value, time()+3600); //设置有效期一小时setcookie(\"TestCookie\", $value, time()+3600, \"/path/\", \"imooc.com\"); //设置路径与域 PHP中还有一个设置Cookie的函数setrawcookie，setrawcookie跟setcookie基本一样，唯一的不同就是value值不会自动的进行urlencode，因此在需要的时候要手动的进行urlencode。 示例： 1setrawcookie('cookie_name', rawurlencode($value), time()+60*60*24*365); 因为Cookie是通过HTTP标头进行设置的，所以也可以直接使用header方法进行设置。 示例： 1header(\"Set-Cookie:cookie_name=value\"); cookie的删除与过期时间 当我们在PHP中用setcookie函数设置了cookie后，需要删除cookie时，也是采用setcookie函数来实现。 示例： 12//添加需要删除的cookie名，value项置空，过期时间定负数setcookie('test', '', time()-1); 上面的例子将cookie的过期时间设置到当前时间之前，则该cookie会自动失效，也就达到了删除cookie的目的。之所以这么设计是因为cookie是通过HTTP的标头来传递的，客户端根据服务端返回的Set-Cookie段来进行cookie的设置，如果删除cookie需要使用新的Del-Cookie来实现，则HTTP头就会变得复杂，实际上仅通过Set-Cookie就可以简单明了的实现Cookie的设置、更新与删除。 根据原理，我们也可以直接通过header来删除cookie。 1234//设置cookie名为test的值为1393832059，然后再设置过期时间。header(\"Set-Cookie:test=1393832059; expires=\".gmdate('D, d M Y H:i:s \\G\\M\\T', time()-1));//这里用到了gmdate，用来生成格林威治标准时间，以便排除时差的影响。 cookie的有效路径 cookie中的路径用来控制设置的cookie在哪个路径下有效，默认为’/‘，在所有路径下都有效，当设定了其他路径之后，则只在设定的路径以及子路径下有效。 123//设置cookie名为：test，值为：1，过期时间0，即浏览器关闭即失效，有效路径为/pathsetcookie('test', '1', 0,'/path'); var_dump($_COOKIE['test']); //使用var_dump函数打印cookie值 上面的设置会使test在/path以及子路径/path/abc下都有效，但是在根目录下就读取不到test的cookie值。 一般情况下，大多是使用所有路径的，只有在极少数有特殊需求的时候，会设置路径，这种情况下只在指定的路径中才会传递cookie值，可以节省数据的传输，增强安全性以及提高性能。 cookie将数据存储在客户端，建立起用户与服务器之间的联系，通常可以解决很多问题，但是cookie仍然具有一些局限： cookie相对不是太安全，容易被盗用导致cookie欺骗 单个cookie的值最大只能存储4k 每次请求都要进行网络传输，占用带宽 存储在服务端的Session session是将用户的会话数据存储在服务端，没有大小限制，通过一个session_id进行用户识别。 默认情况下，session是以文件形式存储在服务器上的，因此当一个页面开启了session之后，会独占这个session文件，这样会导致当前用户的其他并发访问无法执行而等待。可以采用缓存或者数据库的形式存储来解决这个问题。 设置Session 在PHP中使用session非常简单，先执行session_start方法开启session，然后通过全局变量$_SESSION进行session的读写。 session会自动的对要设置的值进行encode（编码）与decode（译码），因此session可以支持任意数据类型，包括数据与对象等。 示例： 123456789101112session_start(); ////调用session_start方法来启用session$_SESSION['string'] = 'jobs'; //名为name，值为jobs$_SESSION['ary'] = array('name',\"age\",'uid' =&gt; \"1250123\"); //一个名为ary的数组$_SESSION['obj'] = new stdClass(); //一个名为obj的对象//输出三个sessionvar_dump($_SESSION['string']);echo \"&lt;br&gt;\"; //空一行显示var_dump($_SESSION['ary']);echo \"&lt;br&gt;\";var_dump($_SESSION['obj']); 删除与销毁session 删除某个session值可以使用PHP的unset函数，删除后就会从全局变量$_SESSION中去除，无法访问。 示例： 12345session_start();$_SESSION['name'] = 'jobs';unset($_SESSION['name']); //删除指定sessionecho $_SESSION['name']; //提示name不存在 如果要删除所有的session，可以使用session_destroy函数销毁当前session，session_destroy会删除所有数据，但是session_id仍然存在。如果需要同时销毁cookie中的session_id，通常在用户退出的时候可能会用到，则还需要显式的调用setcookie方法删除session_id的cookie值。 示例： 12345session_start();$_SESSION['name'] = 'jobs';$_SESSION['time'] = time();session_destroy(); //删除所有 值得注意的是，session_destroy并不会立即的销毁全局变量$_SESSION中的值，只有当下次再访问的时候，$_SESSION才为空，因此如果需要立即销毁$_SESSION，可以使用unset函数。 session与cookie的异同 PHP默认情况下session id是通过cookie来保存的，因此从某种程度上来说，seesion依赖于cookie。但这不是绝对的，session id也可以通过参数来实现，只要能将session id传递到服务端进行识别的机制都可以使用session。 使用session来存储用户的登录信息 session可以用来存储多种类型的数据，因此具有很多的用途，常用来存储用户的登录信息，购物车数据，或者一些临时使用的暂存数据等。 用户在登录成功以后，通常可以将用户的信息存储在session中，一般的会单独的将一些重要的字段单独存储，然后所有的用户信息独立存储。 12$_SESSION['uid'] = $userinfo['uid'];$_SESSION['userinfo'] = $userinfo; 一般来说，登录信息既可以存储在sessioin中，也可以存储在cookie中，他们之间的差别在于session可以方便的存取多种数据类型，而cookie只支持字符串类型，同时对于一些安全性比较高的数据，cookie需要进行格式化与加密存储，而session存储在服务端则安全性较高。 示例： 123456789101112131415161718192021222324252627282930session_start();//假设用户登录成功获得了以下用户数据$userinfo = array( 'uid' =&gt; 10000, 'name' =&gt; 'spark', 'email' =&gt; 'spark@imooc.com', 'sex' =&gt; 'man', 'age' =&gt; '18');header(\"content-type:text/html; charset=utf-8\");/* 将用户信息保存到session中 */$_SESSION['uid'] = $userinfo['uid'];$_SESSION['name'] = $userinfo['name'];$_SESSION['userinfo'] = $userinfo;//* 将用户数据保存到cookie中的一个简单方法 */$secureKey = 'imooc'; //加密密钥$str = serialize($userinfo); //将用户信息序列化//用户信息加密前$str = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), $str, MCRYPT_MODE_ECB));//用户信息加密后//将加密后的用户数据存储到cookie中setcookie('userinfo', $str);//当需要使用时进行解密$str = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), base64_decode($str), MCRYPT_MODE_ECB);$uinfo = unserialize($str);echo \"解密后的用户信息：&lt;br&gt;\";print_r($uinfo); 源自：本篇文章为慕课网PHP入门教程的知识总结声明：以上内容如有不足之处，欢迎联系指正，转载请注明出处！","link":"/2019/08/17/PHP%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6/"},{"title":"PHP基本介绍及知识体系","text":"关于PHP PHP的中文名是超文本预处理器，是一种广泛使用在Web开发领域的跨平台后端脚本语言，面向对象编程，特点是：使用成本低，开发速度快。 PHP后端工程师技术栈主要包括以下内容： Web前端技术与PHP语言 Linux操作系统 MySQL数据库 各种PHP开发框架 缓存技术和海量数据优化技术 系统调优和负载均衡技术 PHP后端工程师应以PHP为主要语言，搭建Web技术栈，全面提升综合素质。 PHP知识体系进阶路线 阶段目标：可以独立完成PHP开发工作 HTML+CSS+JavaScript语言基础 PHP语法基础与高级开发技术 MySQL数据库 API接口开发 熟悉常用PHP开发框架 源码管理工具 PHP测试工具 阶段目标：深入理解PHP开发环境，能够胜任核心代码的编写工作 深入学习HTTP协议 PHP环境高级配置 MySQL数据库优化技术 静态化和缓存技术 网站安全技术 阶段目标：可以根据需求改善技术框架，轻松实现核心组件，攻克技术难关 深入分析PHP框架源代码 深入学习PHP内核 NoSQL型数据库 集群与负载均衡技术 阶段目标：能够对整体需求方案做出精确描述，灵活运用PHP和相关技术进行项目设计 深入学习Linux操作系统 多级缓存技术 海量数据优化技术 容灾技术 大型系统框架设计方法 资深PHP工程师应具备的素养 具备高级PHP工程师的技能和经验 掌握Web服务器相关的核心技术 掌握面向对象的思维方式 能够熟练使用企业应用中常见的开发框架 具备良好的编程习惯并使用高效的方法构建代码 具备独立解决问题的能力 一名IT工程师的进阶，需要不断的学习新的知识，完善技术栈。总结日常踩过的坑，锻炼独立解决问题的能力，才能高效且轻松的完成工作任务。 源自：本篇文章总结自网上前辈的分享、社招的标准、加以作者心得体会而成。声明：不足之处欢迎指正、转载请注明出处！","link":"/2019/08/13/PHP%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"},{"title":"Traceroute路由回显命令","text":"Traceroute概述 Traceroute是一种将数据包途经路由，IP地址回显的指令，基于ICMP协议实现，通过不断发送不可交付的IP数据报，获取从源主机到目标主机的路由IP。 Traceroute工作原理 Traceroute命令（Dos下用tracert命令）从源主机向目的主机发送一连串的IP数据报，数据报中封装的是无法交付的UDP用户数据报，预设数据包大小是40Bytes。。第一个数据报P1的生存时间TTL设置为1。当P1到达路径上的第一个路由器R1时，路由器R1先收下它，接着把TTL的值减一。由于TTL等于零了，R1就把P1丢弃了，并向源主机发送了一个ICMP时间超过差错报告报文。 源主机接着发送第二个数据包P2，并把TTL设置为2。P2先到达路由器R1，R1收下后把TTL减1再转发给路由器R2.R2收到P2时TTL为1，但减1后TTL变为零了。R2就丢弃P2，并向源主机发送一个ICMP时间超过差错报告报文。这样一直继续下去。当最后一个数据报刚刚到达目的主机时，数据报的TTL时1.主机不转发数据报，也不把TTL值减1。但因IP数据报中封装的是无法交付的运输层的UDP用户数据报，因此目的主机要向源主机发送ICMP终点不可达差错报告报文。 这样，源主机就达到了自己的目的，因为这些路由器和最后目的主机发来的ICMP报文正好给出了源主机想知道的路由信息———达到目的主机所经过的路由器的IP地址，以及到达其中的每一个路由器的往返时间。 路由跟踪所花费的时间受路由器数量以及网络拥塞程度影响。 Traceroute命令参数 -d 使用Socket层级的排错功能。 -f&lt;存活数值&gt; 设置第一个检测数据包的存活数值TTL的大小。 -F 设置勿离断位。 -g&lt;网关&gt; 设置来源路由网关，最多可设置8个。 -i&lt;网络界面&gt; 使用指定的网络界面送出数据包。 -I 使用ICMP回应取代UDP资料信息。 -m&lt;存活数值&gt; 设置检测数据包的最大存活数值TTL的大小。 -n 直接使用IP地址而非主机名称。 -p&lt;通信端口&gt; 设置UDP传输协议的通信端口。 -q 设置每一跳的探测包数量。默认是3 。 -r 忽略普通的Routing Table，直接将数据包送到远端主机上。 -s&lt;来源地址&gt; 设置本地主机送出数据包的IP地址。 -t&lt;服务类型&gt; 设置检测数据包的TOS数值。 -v 详细显示指令的执行过程。 -w&lt;超时秒数&gt; 设置等待远端主机回报的时间。 -x 开启或关闭数据包的正确性检验。 [root@localhost ~] traceroute baidu.com #最常用的方法 [root@localhost ~] traceroute -m 10 baidu.com #把跳数设置为10次； [root@localhost ~] traceroute -n baidu.com #显示IP地址，不查主机名 [root@localhost ~] traceroute -p 6888 baidu.com #探测包使用的基本UDP端口设置6888 [root@localhost ~] traceroute -q 4 baidu.com #把探测包的个数设置为值4 [root@localhost ~] traceroute -r baidu.com #绕过正常的路由表，直接发送到网络相连的主机 [root@localhost ~] traceroute -w 3 baidu.com #把对外发探测包的等待响应时间设置为3秒 注：部分内容参考计算机网络相关书籍总结 声明：以上内容如有错漏，欢迎联系指正，转载请注明出处。","link":"/2019/07/24/Traceroute%E8%B7%AF%E7%94%B1%E5%9B%9E%E6%98%BE%E5%91%BD%E4%BB%A4/"},{"title":"linux笔记本配置wifi连接","text":"环境 Debian 9 步骤 1、添加光盘安装源 1$ apt-cdrom add #插入光盘或启动盘，以光盘为源安装 2、获取无线网卡名称并激活 1$ ip addr #查看无线网卡名称 例如名称为:wlo1。 1$ ip link set wlo1 up #激活无线网卡（非必须） 3、安装必备的工具包 1$ apt install net-tools #安装net网络管理工具包 4、搜索附近的wifi并连接 1$ iw wlo1 scan | grep SSID #扫描附近的wifi 例如扫描出要连接的wifi名称：Faith 密码：1258012580 1$ nmcli dev wifi connect Faith password 1258012580 #连接wifi(密码含有空格则用引号括起) 5、查看成功连上并获取到ip 1$ ip addr #查看是否已连接到wifi并获取到IP 6、ping不通百度？测试是否能连上外网 1$ ping 114.114.114.114 #若成功ping通DNS则默认DNS不可用，需添加新的DNS 7、添加DNS 1$ vim /etc/resolv.conf #进入配置文件添加DNS 1$ nameserver 114.114.114.114 #在默认DNS前添加新的DNS 因wifi网络地址默认均为动态分配，重启后resolv.conf文件也需重新添加DNS 声明: 以上内容仅供参考，转载请注明出处.","link":"/2019/04/13/linux%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%85%8D%E7%BD%AEwifi%E8%BF%9E%E6%8E%A5-%E7%AC%94%E8%AE%B0/"},{"title":"《白帽子讲WEB安全》-读书笔记(一)","text":"前言 最近看了一本不错的互联网安全类的书籍，觉得应该留下些什么。《白帽子讲Web安全》为阿里的首席安全专家吴翰清所著。 此书结合了吴翰清在阿里多年的工作经验，对Web安全领域的众多典型案例，站在白帽子的视角，讲述Web安全的方方面面，虽然也剖析攻击原理，但更重要的是如何防范这些问题。 本书对当前WEB应用常见的攻击手法进行了较为全面的概括，本篇文章将就此书所阐述的安全观进行浅显的总结。 对于互联网安全的思考 要以正确的思路去看待安全问题：安全工程师的核心竞争力不在于他能拥有多少个0day，掌握多少种安全技术，而是在于他对安全理解的深度，以及由此引申的看待安全问题的角度和高度。 我们不是要做一个能够解决问题的方案，而是要做一个能够“漂亮地”解决问题的方案。这应该是每一名优秀的安全工程师所应有的追求。 白帽子的定义 不同于以破坏为乐的黑帽子，白帽子是以建设更安全的互联网为己任。 安全的本质 安全问题的本质是信任的问题：一切的安全方案设计的基础，都是建立在信任关系上的。必须有一些最基本的假设，安全方案才能得以建立。 安全是一个持续的过程：攻击和防御技术就是在不断碰撞和对抗中得到发展的。某一时期的攻击或防御技术，都不可能永远有效，永远用下去。这是因为防御技术在发展的同时，攻击技术也在不断发展，两者是相互促进的辩证关系。 安全三要素 机密性：要求保护数据内容不能泄露，加密是实现机密性要求的常见手段。 完整性：要求保护数据内容是完整、没有被篡改的。常见的保证一致性的技术手段是数字签名。 可用性：要求保护资源是“随需而得”。拒绝服务攻击Dos破坏的就是安全的可用性。 安全评估的四阶段 安全评估的过程，可以简单地分为4个阶段： 资产等级划分 威胁分析 风险分析 确认解决方案 互联网安全的核心问题，是数据安全的问题。 白帽子兵法 Secure By Default 原则 黑名单、白名单 最小权限原则 纵深防御原则 数据与代码分离原则 不可预测性原则 安全是一门朴素的学问，也是一种平衡的艺术。 本篇文章是以《白帽子讲web安全》为基础，结合自身见解而成。如有错漏，请联系指正，转载请注明出处！","link":"/2019/07/21/%E3%80%8A%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2WEB%E5%AE%89%E5%85%A8%E3%80%8B-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"使用SSH登陆Linux常见问题","text":"环境 centos 7 minimal Root登陆被禁止 问题描述首次使用ssh登陆一个刚装的Centos minimal版系统时，使用root账户登陆连续提示：权限被拒绝，请再次输入密码 异常提示： 123456$ ssh root@192.168.20.130root@192.168.20.130's password:Permission denied, please try again.root@192.168.20.130's password:Permission denied, please try again.root@192.168.20.130's password: 问题原因可能是：root登陆被禁止 解决方法修改配置文件sshd_config，文件路径/etc/ssh/sshd_config 修改PermitRootLogin参数为yes，并去掉注释符#，如下： 1PermitRootLogin yes #允许使用ssh进行root登陆 以密码登陆账户被禁止 问题描述使用密码登陆被拒绝访问并提示：“权限被拒绝”错误，提示可用公钥登陆 异常提示： 12$ ssh root@192.168.20.10root@192.168.20.10: Permission denied (publickey,gssapi-keyex,gssapi-with-mic). 问题原因可能是：sshd禁止了使用密码来登陆该系统，但可用公钥验证身份。 解决方法修改配置文件sshd_config，文件路径/etc/ssh/sshd_config 修改PasswordAuthentication参数为yes，并去掉注释符#，如下： 123# To disable tunneled clear text passwords, change to no here! PasswordAuthentication yes #允许ssh使用密码验证账户 保存配置并返回到系统视图下执行 1service sshd restart #重启sshd服务使配置生效 注：以上内容如有错漏，欢迎联系指正，转载请注明出处！","link":"/2019/08/18/%E4%BD%BF%E7%94%A8SSH%E7%99%BB%E9%99%86Linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"title":"搭建Hexo静态博客笔记","text":"环境 Debian 9依赖：Node.js、Hexo 搭建Hexo 1、安装Node.js 下载源码包编译安装 2、安装Hexo 1$ npm install hexo-cli -g #npm为国外源可能速度较慢，根据需要可换cnpm 3、新建一个blog目录 1$ mkdir blog #博客的根目录 4、cd至根目录 1$ cd blog #后续操作皆在此目录下进行 5、构建博客 1$ hexo init #生成基本博客架构 6、启动Hexo 1$ hexo s #可使用-p指定访问端口 启动完成后会显示本地访问地址如http://localhost:4000浏览器输入地址访问即可，到此静态Hexo博客已搭建完成。 基本指令操作 1、新建一篇博文 1$ hexo n \"我的第一篇博文\" 2、编辑博文,blog目录下 1$ cd source/_posts/ #此目录下为博客源文档 3、编译博文 1$ hexo g #将源文档编译成网页文件 ps.需要查看新建的博文，再次hexo s启动查看即可 github部署 1、新建github仓库 仓库名称：xxxx.github.io 复制仓库SSH上传链接。 2、安装Git插件 1$ npm install --save hexo-deployer-git #部署依赖插件 3、配置.config.yml 1$ vim .config.yml 添加github仓库地址 找到以下位置并补全： 1234deploy:type: gitrepo: https://github.com/WebFaith/webfaith.github.io.gitbranch: master 4、上传 1$ hexo d #将本地博客上传挂载至github 上传成功地址以仓库名称即可访问，例如xxxx.github.io Ps: 以上内容仅供参考，转载请注明出处。","link":"/2019/04/12/%E6%90%AD%E5%BB%BAhexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B/"},{"title":"校园网下VBox虚拟机配置双网卡互通","text":"前言 有些新手在第一次使用VirtualBox搭建linux实验平台初期，总会碰到一些稀奇古怪的上网问题，若是校园网类的认证上网环境，则坑会更多，双网卡配置是个不错的解决方法。 VirtualBox的网卡连接方式区别： 1、桥接网卡：此方式可以实现虚拟机与宿主机互通，并且上网。（寻常局域网环境这个连接方式就可以解决本次问题，但因为在认证网的环境中，这个方式并没有解决）默认网段：192.168.1.0优点：可以轻松实现上网，同网段主机可以任意互通。缺点：占用网段中的IP地址。 2、网络地址转换NAT：此方式是借助NAT功能通过宿主机所在的网络来访问公网，虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改。默认网段：10.0.2.0优点：轻松实现上网，不占用网段中的IP地址。缺点：虚拟机可以访问宿主机，但宿主机无法访问虚拟机，虚拟机彼此间也不通。 3、仅主机网络(Host-Only)：此方式下，虚拟机与真实网络是隔离开的，访问不了互联网，但是虚拟机之间可以互通。默认网段：192.168.56.0优点：可以和真实的网络环境隔离，宿主机与虚拟机可以互通。缺点：虚拟机无法上网。 实验环境 VirtualBox+centos7+校园网 实验步骤 1、centos系统miniual安装默认网卡不是自启动的，需要开启才能连上网 12$ vim /etc/sysconfig/network-scripts/ifcfg-网卡名称 #把ONBOOT=no的no改为yes$ /etc/init.d/network restart #重启网络 2、双网卡设置找到：虚拟机-&gt;控制-&gt;设置-&gt;网络（1）设置网卡1的连接方式为：网络地址转换(NAT) （2）启用网卡2的连接方式为：仅主机网络(Host-Only) 利用NAT模式的上网功能和Host-Only的主机互通功能组合，网卡双开，可实现认证网络下宿主机和虚拟机互通、上网。 声明: 以上内容仅供参考，不足之处敬请指正，转载请注明出处。","link":"/2019/05/14/%E6%A0%A1%E5%9B%AD%E7%BD%91%E4%B8%8BVBox%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8F%8C%E7%BD%91%E5%8D%A1%E4%BA%92%E9%80%9A/"},{"title":"配置Firewall防火墙服务常用命令","text":"前言 在Linux环境中的防火墙设置、端口开放关闭，都是由firewalld服务进行管理的，firewalld的firewalld-cmd就是用来修改配置防火墙的命令行客户端，类似于windows中的cmd一样。 环境 centos 7 常用命令 1、查看zone（作用域）信息 123$ firewall-cmd --list-all-zones #显示防火墙所有域配置信息$ firewall-cmd --get-active-zones #查看活动中的域 2、开放关闭某项服务 12345$ firewall-cmd --zone=public --add-service=http --permanent #在public永久开放某项服务,例如http，添加--permanent永久生效，不加重启失效$ firewall-cmd --zone=public --remove-service=http --permanent #在public永久移除某项服务，例如http$ firewall-cmd --zone=public --list-services #查看public作用域中的服务 3、开放关闭某端口 123$ firewall-cmd --zone=public --add-port=80/tcp --permanent #在public中永久开放某端口，例如80$ firewall-cmd --remove-port=80/udp --permanent #永久移除某端口 4、重新加载配置 1$ firewall-cmd --reload #重新加载才会立即生效 5、firewall防火墙启动与关闭 123456789$ systemctl start firewalld.service #开启防火墙服务$ systemctl restart firewalld.service #重启防火墙服务$ systemctl stop firewalld.service #关闭防火墙服务$ systemctl enable firewalld.service #开机自动启动$ systemctl disable firewalld.service #关闭开机自动启动 6、查看监听的端口 123$ netstat -lntp #查看所有在运行端口信息$ netstat -lnp | grep 80 #查看端口被哪个进程占用 注释 作用域（zone）:丢弃区域（Drop Zone）：如果使用丢弃区域，任何进入的数据包将被丢弃。这个类似与我们之前使用iptables -j drop。使用丢弃规则意味着将不存在响应，只有流出的网络连接有效。 阻塞区域（Block Zone）：阻塞区域会拒绝进入的网络连接，返回icmp-host-prohibited，只有服务器已经建立的连接会被通过。 公共区域（Public Zone）：只接受那些被选中的连接，而这些通过在公共区域中定义相关规则实现。服务器可以通过特定的端口数据，而其它的连接将被丢弃。 外部区域（External Zone）：这个区域相当于路由器的启用伪装（masquerading）选项。只有指定的连接会被接受，而其它的连接将被丢弃或者不被接受。 隔离区域（DMZ Zone）：如果想要只允许给部分服务能被外部访问，可以在DMZ区域中定义。它也拥有只通过被选中连接的特性。 工作区域（Work Zone）：在这个区域，我们只能定义内部网络。比如私有网络通信才被允许。 家庭区域（Home Zone）：这个区域专门用于家庭环境。我们可以利用这个区域来信任网络上其它主机不会侵害你的主机。它同样只允许被选中的连接。 内部区域（Internal Zone）：这个区域和工作区域（Work Zone）类似，只有通过被选中的连接。 信任区域（Trusted Zone）：信任区域允许所有网络通信通过。 声明: 以上内容仅供参考，不足之处敬请指正，转载请注明出处。","link":"/2019/05/08/%E9%85%8D%E7%BD%AEFirewall%E9%98%B2%E7%81%AB%E5%A2%99%E6%9C%8D%E5%8A%A1%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}],"tags":[{"name":"Web全栈架构","slug":"Web全栈架构","link":"/tags/Web%E5%85%A8%E6%A0%88%E6%9E%B6%E6%9E%84/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"综合技术栈","slug":"综合技术栈","link":"/tags/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"版本管理","slug":"版本管理","link":"/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"网络技术","slug":"网络技术","link":"/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"},{"name":"数通","slug":"数通","link":"/tags/%E6%95%B0%E9%80%9A/"},{"name":"命令详解","slug":"命令详解","link":"/tags/%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"name":"Linux系统运维","slug":"Linux系统运维","link":"/tags/Linux%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"},{"name":"debian系","slug":"debian系","link":"/tags/debian%E7%B3%BB/"},{"name":"Web安全","slug":"Web安全","link":"/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"RedHat系","slug":"RedHat系","link":"/tags/RedHat%E7%B3%BB/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"虚拟机","slug":"虚拟机","link":"/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"红帽系","slug":"红帽系","link":"/tags/%E7%BA%A2%E5%B8%BD%E7%B3%BB/"},{"name":"端口","slug":"端口","link":"/tags/%E7%AB%AF%E5%8F%A3/"}],"categories":[{"name":"Web全栈架构","slug":"Web全栈架构","link":"/categories/Web%E5%85%A8%E6%A0%88%E6%9E%B6%E6%9E%84/"},{"name":"综合技术栈","slug":"综合技术栈","link":"/categories/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"JavaScript","slug":"Web全栈架构/JavaScript","link":"/categories/Web%E5%85%A8%E6%A0%88%E6%9E%B6%E6%9E%84/JavaScript/"},{"name":"PHP","slug":"Web全栈架构/PHP","link":"/categories/Web%E5%85%A8%E6%A0%88%E6%9E%B6%E6%9E%84/PHP/"},{"name":"版本管理","slug":"综合技术栈/版本管理","link":"/categories/%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF%E6%A0%88/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"网络技术","slug":"网络技术","link":"/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"},{"name":"运维技术","slug":"运维技术","link":"/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"},{"name":"网站搭建","slug":"Web全栈架构/网站搭建","link":"/categories/Web%E5%85%A8%E6%A0%88%E6%9E%B6%E6%9E%84/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"},{"name":"数通","slug":"网络技术/数通","link":"/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/%E6%95%B0%E9%80%9A/"},{"name":"Linux系统配置","slug":"运维技术/Linux系统配置","link":"/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/Linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"},{"name":"Web安全","slug":"网络技术/Web安全","link":"/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/Web%E5%AE%89%E5%85%A8/"}]}